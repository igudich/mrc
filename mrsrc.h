//          Copyright Maarten L. Hekkelman 2006-2020
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef MRSRC_H
#define MRSRC_H

#include <string>
#include <list>
#include <exception>
#include <istream>

/*
	Resources are data sources for the application.
	
	They are retrieved by name.

	Basic usage:
	
	mrsrc::rsrc rsrc("dialogs/my-cool-dialog.glade");
	
	if (rsrc)
	{
		GladeXML* glade = glade_xml_new_from_buffer(rsrc.data(), rsrc.size(), NULL, "japi");
		
		...
	}

	Alternative, to loop over all resources:

	mrsrc rsrc;		// <- the root resource
	for (rsrc child: rsrc)
		std::cout << child.name() << std::endl;

	-------------------------------------------------

	Stream interface:

	mrsrc::streambuf rb("data/my-text.txt");
	std::istream is(&rb);

	std::string line;
	while (std::gettline(is, line))
		std::cout << line << std::endl;

*/

namespace mrsrc
{
	/// \brief Internal data structure as generated by mrc
	struct rsrc_imp
	{
		unsigned int m_next;
		unsigned int m_child;
		unsigned int m_name;
		unsigned int m_size;
		unsigned int m_data;
	};
} // namespace mrsrc

// The following three variables are generated by mrc:

extern const mrsrc::rsrc_imp gResourceIndex[];
extern const char gResourceData[];
extern const char gResourceName[];

namespace mrsrc
{
	/// \brief Class mrsrc::rsrc contains a pointer to the data in the
	/// resource, as well as offering an iterator interface to its
	/// children.

	class rsrc
	{
	  public:

		rsrc() : m_impl(gResourceIndex) {}

		rsrc(const rsrc &other)
			: m_impl(other.m_impl) {}

		rsrc &operator=(const rsrc &other)
		{
			m_impl = other.m_impl;
			return *this;
		}

		rsrc(const std::string &path);

		std::string name() const { return gResourceName + m_impl->m_name; }

		const char* data() const { return gResourceData + m_impl->m_data; }

		unsigned long size() const { return m_impl->m_size; }

		explicit operator bool() const { return m_impl != NULL and m_impl->m_size > 0; }

		template<typename RSRC>
		class iterator_t
		{
		  public:

			using iterator_category = std::input_iterator_tag;
			using value_type = RSRC;
			using difference_type = std::ptrdiff_t;
			using pointer = value_type*;
			using reference = value_type&;

			iterator_t(const rsrc_imp* cur)
				: m_cur(cur) {}

			iterator_t(const iterator_t& i);
			iterator_t& operator=(const iterator_t& i);

			reference operator*()		{ return m_cur; }
			pointer operator->()		{ return &m_cur; }

			iterator_t& operator++()
			{
				if (m_cur.m_impl->m_next)
					m_cur.m_impl = gResourceIndex + m_cur.m_impl->m_next;
				else
					m_cur.m_impl = nullptr;
				return *this;
			}

			iterator_t operator++(int)
			{
				auto tmp(*this);
				this->operator++();
				return tmp;
			}

			bool operator==(const iterator_t& rhs) const		{ return m_cur.m_impl == rhs.m_cur.m_impl; }
			bool operator!=(const iterator_t& rhs) const		{ return m_cur.m_impl != rhs.m_cur.m_impl; }

		  private:
			value_type	m_cur;
		};

		using iterator = iterator_t<rsrc>;

		iterator begin() const
		{
			const rsrc_imp* impl = nullptr;
			if (m_impl and m_impl->m_child)
				impl = gResourceIndex + m_impl->m_child;
			return iterator(impl);
		}

		iterator end() const
		{
			return iterator(nullptr);
		}

	  private:
		rsrc(const rsrc_imp* imp)
			: m_impl(imp) {}

		const rsrc_imp *m_impl;
	};

	inline rsrc::rsrc(const std::string &path)
	{
		m_impl = gResourceIndex;

		// using std::filesytem::path would have been natural here of course...
		std::string p(path);
		while (m_impl != nullptr and not p.empty())
		{
			std::string::size_type s = p.find('/');
			std::string name;

			if (s != std::string::npos)
			{
				name = p.substr(0, s);
				p.erase(0, s + 1);
			}
			else
				std::swap(name, p);

			const rsrc_imp* impl = nullptr;
			for (rsrc child: *this)
			{
				if (child.name() == name)
				{
					impl = child.m_impl;
					break;
				}
			}

			m_impl = impl;
		}
	}

	// --------------------------------------------------------------------
	
	class streambuf : public std::streambuf
	{
	  public:

		/// \brief constructor taking a \a path to the resource in memory
		streambuf(const std::string& path)
			: m_rsrc(path)
			, m_begin(m_rsrc.data()), m_end(m_rsrc.data() + m_rsrc.size()), m_current(m_rsrc.data())
		{
		}

		/// \brief constructor taking a \a rsrc 
		streambuf(const rsrc& rsrc)
			: m_rsrc(rsrc)
			, m_begin(m_rsrc.data()), m_end(m_rsrc.data() + m_rsrc.size()), m_current(m_rsrc.data())
		{
		}

		streambuf(const streambuf&) = delete;
		streambuf& operator=(const streambuf&) = delete;

	  private:

		int_type underflow()
		{
			if (m_current == m_end)
				return traits_type::eof();

			return traits_type::to_int_type(*m_current);
		}

		int_type uflow()
		{
			if (m_current == m_end)
				return traits_type::eof();

			return traits_type::to_int_type(*m_current++);
		}

		int_type pbackfail(int_type ch)
		{
			if (m_current == m_begin or (ch != traits_type::eof() and ch != m_current[-1]))
				return traits_type::eof();

			return traits_type::to_int_type(*--m_current);
		}

		std::streamsize showmanyc()
		{
			assert(std::less_equal<const char*>()(m_current, m_end));
			return m_end - m_current;
		}

		pos_type seekoff(std::streambuf::off_type off, std::ios_base::seekdir dir, std::ios_base::openmode which)
		{
			switch (dir)
			{
				case std::ios_base::beg:
					m_current = m_begin + off;
					break;

				case std::ios_base::end:
					m_current = m_end + off;
					break;

				case std::ios_base::cur:
					m_current += off;
					break;
				
				default:
					break;
			}

			if (m_current < m_begin)
				m_current = m_begin;
			
			if (m_current > m_end)
				m_current = m_end;

			return m_current - m_begin;
		}

		pos_type seekpos(std::streambuf::pos_type pos, std::ios_base::openmode which)
		{
			m_current = m_begin + pos;

			if (m_current < m_begin)
				m_current = m_begin;
			
			if (m_current > m_end)
				m_current = m_end;

			return m_current - m_begin;
		}

	  private:
		rsrc m_rsrc;
		const char* const m_begin;
		const char* const m_end;
		const char* m_current;
	};

} // namespace mrsrc

#endif
