//          Copyright Maarten L. Hekkelman 2006-2020
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef MRSRC_H
#define MRSRC_H

#include <string>
#include <list>
#include <exception>

/*
	Resources are data sources for the application.
	
	They are retrieved by name.

	Basic usage:
	
	mrsrc::rsrc rsrc("dialogs/my-cool-dialog.glade");
	
	if (rsrc)
	{
		GladeXML* glade = glade_xml_new_from_buffer(rsrc.data(), rsrc.size(), NULL, "japi");
		
		...
	}

	Alternative, to loop over all resources:

	mrsrc rsrc;		// <- the root resource
	for (rsrc child: rsrc)
		std::cout << child.name() << std::endl;
*/

namespace mrsrc
{
	struct rsrc_imp
	{
		unsigned int m_next;
		unsigned int m_child;
		unsigned int m_name;
		unsigned int m_size;
		unsigned int m_data;
	};
} // namespace mrsrc

// The following three variables are generated by the japi resource compiler:

extern const mrsrc::rsrc_imp gResourceIndex[];
extern const char gResourceData[];
extern const char gResourceName[];

namespace mrsrc
{
	class rsrc
	{
	  public:

		rsrc() : m_impl(gResourceIndex) {}

		rsrc(const rsrc &other)
			: m_impl(other.m_impl) {}

		rsrc &operator=(const rsrc &other)
		{
			m_impl = other.m_impl;
			return *this;
		}

		rsrc(const std::string &path);

		std::string name() const { return gResourceName + m_impl->m_name; }

		const char* data() const { return gResourceData + m_impl->m_data; }

		unsigned long size() const { return m_impl->m_size; }

		explicit operator bool() const { return m_impl != NULL and m_impl->m_size > 0; }

		template<typename RSRC>
		class iterator_t
		{
		  public:

			using iterator_category = std::input_iterator_tag;
			using value_type = RSRC;
			using difference_type = std::ptrdiff_t;
			using pointer = value_type*;
			using reference = value_type&;

			iterator_t(const rsrc_imp* cur)
				: m_cur(cur) {}

			iterator_t(const iterator_t& i);
			iterator_t& operator=(const iterator_t& i);

			reference operator*()		{ return m_cur; }
			pointer operator->()		{ return &m_cur; }

			iterator_t& operator++()
			{
				if (m_cur.m_impl->m_next)
					m_cur.m_impl = gResourceIndex + m_cur.m_impl->m_next;
				else
					m_cur.m_impl = nullptr;
				return *this;
			}

			iterator_t operator++(int)
			{
				auto tmp(*this);
				this->operator++();
				return tmp;
			}

			bool operator==(const iterator_t& rhs) const		{ return m_cur.m_impl == rhs.m_cur.m_impl; }
			bool operator!=(const iterator_t& rhs) const		{ return m_cur.m_impl != rhs.m_cur.m_impl; }

		  private:
			value_type	m_cur;
		};

		using iterator = iterator_t<rsrc>;

		iterator begin() const
		{
			const rsrc_imp* impl = nullptr;
			if (m_impl and m_impl->m_child)
				impl = gResourceIndex + m_impl->m_child;
			return iterator(impl);
		}

		iterator end() const
		{
			return iterator(nullptr);
		}

	  private:
		rsrc(const rsrc_imp* imp)
			: m_impl(imp) {}

		const rsrc_imp *m_impl;
	};

	inline rsrc::rsrc(const std::string &path)
	{
		m_impl = gResourceIndex;

		// using std::filesytem::path would have been natural here of course...
		std::string p(path);
		while (m_impl != nullptr and not p.empty())
		{
			std::string::size_type s = p.find('/');
			std::string name;

			if (s != std::string::npos)
			{
				name = p.substr(0, s);
				p.erase(0, s + 1);
			}
			else
				std::swap(name, p);

			const rsrc_imp* impl = nullptr;
			for (rsrc child: *this)
			{
				if (child.name() == name)
				{
					impl = child.m_impl;
					break;
				}
			}

			m_impl = impl;
		}
	}

} // namespace mrsrc

#endif
